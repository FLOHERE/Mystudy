# 중요한거만 정리한거임
## 01 프로세스 없는 소프트웨어 개발
### 프로세스 없는 소프트웨어 개발
- 일반적인 툴
	- 프로젝트 관리자, 팀 구성원들이
	- 어떤 작업을 해야 하고
	- 어떤 순서로 작업을 해야 하는지 
	- 전체적인 틀 제공
- 구체적인 방법
	- 프로세스 각 단계 작업의
	- 자세한 입력 자료,
	- 산출물의 표현
	- 각 작업을 어떤식으로 하는지 제시하는 것.

### 소프트웨어 프로세스 VS 방법론
- 프로세스(what)
	- 단계적인 작업의 틀을 정한 것.
	- 무엇을 하는가에 중점
	- 결과물의 표현에 대하여 언급 없음
	- 패러다임에 독립적
	- 각 단계가 다른 방법론으로도 실현 가능
	- ex_) 폭포수, 나선형, 프로토, Unified, 애자일 프로세스
- 방법론(how)
	- 프레스의 구체적인 구현에 이름.
	- 어떻게 하는가에 중점
	- 결과물을 어떻게 표현하는지 표시
	- 패러다임에 종속적
	- 각 단계의 절차, 기술, 가이드라인을 제시
	- ex_)구조적 분석, 설계 방법론, 객체 지향 방법론, 컴포넌트, 애자일 방법론

### 소프트웨어 개발 과정
![[소프트웨어 개발 과정.canvas]]

## 02 프로세스 종류

### 프로세스
- 개발 프로세스
>[!note] 소프트웨어 프로세스
>소프트웨어 개발에 대한 기술적 , 관리적 이슈를 다루는 직업

![[프로세스의 종류.canvas]]
### 좋은 프로세스가 가져야 할 특징
1. 예측 가능성
2. 테스팅과 유지 보수 용이성
3. 변경 용이성
4. 결함 제거 용이성

#### 1. 예측가능성
- 프로젝트의 성공적인 수행(완성) 을 위해서 적용한 프로세스를 사용할 경우 비용, 품질등의 예측이 가능한가.

#### 2. 테스팅과 유지보수 용이성
- 소프트웨어 개발 비용< 유지보수 비용
- 프로젝트 각 단계별 비용 : 코딩(30%) < 테스팅(50%)
- 결국 , 프로세스의 목적은...
	- 설계, 코딩에 드는 노력을 낮추는 것X
	- 테스팅 , 유지보수에 드는 노력을 낮추는 것.
	- => 테스팅과 유지보수가 쉽도록 소프트웨어를 설계하고 코딩
- => 개발 프로세스를 정할때 중요 이슈는 테스팅과 수정을 쉽게 할수 있도록 하는것.

#### 3. 변경 용이성
- 조직, 비즈니스 변경 등 여러가지 이유로 인한 소프트웨어 변경이 빈번히 발생
	- => 소프트웨에 대한 빈번한 변경요구 가능성을 고려할때, 변경을 쉽게 다룰수 있는 프로세스 필요.

#### 4. 결함 제거 용이성
- 소프트웨어 개발의 전 단계에서 오류 발생 가능성 있음
- 요구분석 단계 = 20%, 설계단계 = 30% , 코딩단계 = 50%
- 오류가 발생 된 후, 발견이 지연될 수록 수정에 드는 비용 증가
- 개발 각 단계에서 발생한 오류는 그 단계에서 수정되도록 오류 탐색
	- 코딩 이후 오류 수정 = 설계, 코드 모두 변경 = 개고생
- 수정 작업은 프로세스 전체, 각 단계별로 이루어져서 , 각 단계의 출력을 다음단계 시작전에 검증 할수 있도록

## 03 프로세스 모델
- 폭포수 모델 : 전통적인 방법
- 프로토타입 모델 : 사용자 의견 중시
- 점증적 개발 모델 : 단계적 개발
- 나선형 모델 : 위험 관리 중시
- 애자일 모델 : 문서화 보다는 프로그래밍에 집중

### 폭포수 모델
![[폭포수 모델.canvas]]
- 가장 오래되고 널리 사용된 프로세스 모델
- 계획 , 운영, 유지보수 까지 각 프로세스를 순서대로 수행
- 각 프로세스 사이에 결과물이 있어 명확한 구분 가능.
- 각 단계가 끝난 후에 결과물을 명확히 정의해야 함.
- 직능 중심의 프로젝트 조직에 적합
- 요구분석, 설계 등 각 작업을 전문으로 하는 팀을 구성하여 작업
- 단순하거나 개발자가 응용분야를 잘 알고 있는 경우에 적합
- 개발자가 애플리케이션에 대해 경험과 지식이 있고 , 고객이 무엇을 원하는지 잘 알고 있고, 요구사항이 크게 변하지 않는 장기간 프로젝트에 적합

### 폭포수 모델 장/단점
#### 장점
- 프로세스가 단순하다
- 초보자가 쉽게 적용이 가능하다.
- 중간 산출물이 명확하다. 
- 관리하기 좋다.

#### 단점
- 이전 단계의 문제가 발견되지 않고 넘어가는 문제 발생
- 처음 단계를 지나치게 강조하면 코딩, 테스트 지연
- 각 단계의 전환에 많은 노력
- 프로토 타입과 재사용의 기회가 줄어듦
- 소용없는 다종의 문서를 생산할 가능성 있음.

### V모델 : 폭포수 모델에서 검증 부분을 보완
![[Pasted image 20231025220028.png]]
![[프로토 타이핑 모델.canvas]]
### 프로토타이핑 모델
- 요구 사항에 대한 피드백을 받기 위해 시스템을 실험적으로 만들어 사용자에게 보여주고 평가하게 하는 방법
- 프로토 타이핑의 목적
	- 단순한 요구 추출 - 만들고 버림
	- 제작 가능성 타진 - 개발 단계에서 유지 보수가 이루어짐

### 프로토 타이핑 모델의 적용
- 개발 착수 시점에 요구가 불투명 할때
- 실험적으로 실현 가능성을 타진해 보고 싶을때
- 혁신적인 기술을 사용해 보고 싶을때.

### 프로토 타이핑 모델의 장/단점

#### 장점
- 사용자의 의견 반영이 잘됨.
- 사용자가 더 관심을 가지고 참여 할수 있고 개발자는 요구를 더 정확히 도출할 수 있음

#### 단점
- 오해, 기대심리 유발
- 관리가 어려움

### 나선형 모델
![[Pasted image 20231025220947.png]]
- 소프트 웨어의 기능을 나누어 점증적으로 개발
- 1~4단계를 반복, 순환하면서 시스템을 확대시켜 나가는 방법
	1. 목표, 방법, 제약 조건 결정
	2. 위험 요소 분석 및 해결
	3. 개발과 평가
	4. 다음 단계의 계획
	=> 위험 분석에 많은 비중을 둚

### 나선형 모델 - 적용
- 재정적, 기술적으로 부담이 큰 경우
- 요구사항이나 아키텍쳐를 이해 하기 어려운 경우
- 근본적으로 성능에 문제가 있거나, 중심이 되는 기술에 문제가 있는 경우

### 나선 모델 장/단점
#### 장점
- 대규모 시스템 개발에 적용하기 좋음
- 반복적인 개발 및 테스트 할때 - 강인성 향상
- 한 사이클에 추가 못한 기능은 다음 단계에서 추가 가능

#### 단점
- 관리가 복잡하다
- 위험 분석을 잘못하여 지나친 경우 피해가 크다.

### 진화적 모델
![[Pasted image 20231025221359.png]]

### 진화적 모델 릴리스 구성 방법
- 점증적 방법
	- 기능별로 릴리스
- 반복적 방법
	- 릴리스 할 때 마다 기능의 완성도를 높임

### 진화적 모델
- 시스템의 핵심 부분, 개발 효과가 좋은 부분에 대하여 기능을 명확하게 하여 우선적으로 개발
- 이를 계속 개선하여 나중에 사용될 시스템으로 진화시켜 나가는 방법
- 시스템을 여러번의 사이클에 나누어 개발 -> 초기 단계에 모든 요구 사항을 파악하여 확장할 필요가 없음
- 시스템 개발 도중에 요구 추가, 변경이 용이
- 위험도가 높은 기술 적용 가능
- 개발과 테스트 반복 -> 위험 낮춤

### 진화적 모델 장/단점
#### 장점
- 몇가지 기능이 부족하더라도 초기에 사용 교육 가능
- 사용자의 요구를 빠르게 반영
- 새로운 기능을 가진 소프트웨어에 대한 시장을 빨리 형성
- 자주 릴리스 -> 가동중인 시스템에서 일어나는 예상하지 못했던 문제를 신속하고 꾸준하게 고쳐 나갈 수 있음.
- 릴리스마다 다른 영역에 초점 두기 가능

#### 단점
- 프로젝트 관리가 복잡해지기 때문에 큰 프로젝트 부적합
- 끝이 안보일수 있어 실패의 위험이 커짐
- 프로젝트의 진행이 위험 분석에 크게 의존

### Unified Process모델
![[Pasted image 20231025221929.png]]
1. 도입(inception)
	- 1,2회 정도 반복으로 도입 단계를 진행
	- 간단한 유스케이스 모델과 소프트웨어 구조 , 프로젝트 계획을 작성
2. 정련(elaboration)(구체화)
	- 여러번의 반복 과정으로 이루어짐
	- 대부분의 유스케이스 작성
	- 아키택쳐 설계, 상세한 프로젝트 계획
3. 구축(construction)
	- 남아있는 유스케이스에 대하여 구현하고 통합
	- 시스템을 목표 환경에 점증적으로 설치
4. 전환(transition)
	- 시스템을 배치, 사용자를 교육
	- 베타 테스팅, 결함 수정, 기능 개선

### Unified Process 모델 장/단점
#### 장점
- 고객의 요구 변경과 관련된 리스크를 적극적으로 해결
- 통합을 위한 노력과 시간을 줄일수 있음
- 쉽고 빠르게 코드를 재사용

#### 단점
- 프로세스가 너무 복잡, 이해하기 어렵고 정확히 적용하기 어렵다.
- 소프트웨어 프로젝트 참여자들의 협동, 의사소통에 대한 가의드가 없음

### 애자일 모델
- 초기의 폭포수 모델은 개발 중, 고객의 변경 요청을 처리하고 통합하는데 많은 비용과 시간 필요
- 단점을 극복 -> 프로젝트에 대한 피드백을 빨리 받고 평가하여 짧은 피드백 반복
- 2001년 17명의 소프트웨어 개발 리더들이 모여 정리한 애자일 선언에 기초, 빠르고 적응력 높은 개발 기술 총칭
- 2~6주가 짧은 주기로 개발을 반복하여 부분적인 기능을 완성
- 사용자는 개발 초기에도 개발 소프트웨어를 사용하고 확인 가능

### 애자일의 기본 가치
- 프로세스와 도구 중심이 아닌, 개개인과의 상호 소통을 중시
- 문서 중심이 아닌, 실행 가능한 소프트웨어 중시
- 계약과 협상 중심이 아닌, 고객과의 협력을 중시
- 계획 중심이 아닌, 변화에 대한 민첩한 대응을 중시
- 환경과 고객의 변화에 능동적으로 대처하는 것을 강조

#### 익스트림 프로그래밍
- 사용자 스토리
	- 시스템 기능의 정의를 요구사항 문서를 통해 하는 것이 아님
	- 간단한 사용자 스토리로 작성
	- 사용자 스토리는 각 기능의 비즈니스 가치, 우선순위로 정함
	- 사용자 스토리를 짧은 싸이클로 구현
- 매일 빌드와 통합 : CI(Continous Integration)
	- 개발 코드를 매일 빌드, 통합
- 테스트 주도 개발 : TDD
	- 코딩 하기 전에
	- 요구사항을 검증하는 테스트 시나리오 작성
	- 테스트 시나리오를 통과하기 위한 최소한의 코드 생성
	- 마지막으로 작성한 코드를 표준에 맞도록 리팩토링
- 페어 프로그래밍
	- 두명의 프로그래머가 하나의 컴퓨터를 공유 하면서 
	- 한사람은 코딩, 다른 한사람은 확인하면서 개발
	- 두 사람이 짝을 이루어 프로그래밍에 대한 지식 공유

#### 스크럼
- 소프트웨어 팀 관리 방법
- 개발 팀원 모두가 함께 소통하고 협력하여 짧은 주기를 반복하며 소프트웨어 개발 하는 작업, 역할 , 결과물
- 백로그를 정하고, 여기에 우선순위 부여, 짧은 주기(스프린트)를 반복하여 출시 -> 주기 단축, 개발
- 용어
	- 스크럼 - 팀, 팀관리 방법
	- 백로그 - 개발 요구사항(사용자 스토리 개념)
	- 스프린트 - 개발 Cycle
	- 프로덕트 백 로그 - 고객과 소통하는 매개체 
	- 스크럼 미팅 - 매일의 팀 미팅
	- 스프린트 백 로그 - 진행사항 게시판/게시물

### 스크럼 장/단점
#### 장점
- 빠른 배포 , 즉각적인 피드백 수용
- 항상 최신 작업을 수행 -> 자원 낭비가 적다
- 문제, 결함을 빨리 감지하고 수정
- 계측적 관료주의 , 불필요한 문서화 등에 시간 덜씀

#### 단점
- 문서화가 등한시 되어 개발자의 속도를 높이기가 어려움
- 고객과의 지속적 상호작용을 해야 하므로 , 더 많은 시간과 에너지 요구
- 명확한 끝이 정의되지 않으면 프로젝트가 종료되지 않고 계속 사용

