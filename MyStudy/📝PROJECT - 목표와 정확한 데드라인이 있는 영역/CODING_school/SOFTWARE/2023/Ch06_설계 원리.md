## 00 개요
### 요구분석
- '무엇을 만들것인가' 를 다루는 작업
- 설계 : '어떻게 실현할 것인가' 를 결정

### 1) 기본 구조 설계
: 아키텍쳐 설계로 각 모듈의 역할과 인터페이스 정의

### 2) 상세 설계
: 모듈 내부의 알고리즘, 데이터를 명세화

- 요구분석 : 고객 , 사용자로부터 요구사항과 프로토 타이핑을 개발자가 파악
- 설계 : 고객과 사용자가 솔루션을 제공하면 그에 맞게 개발자 쪽에서 설계

## 01 설계 기본 개념
### 설계
- 높은 수준의 의사결정 과정의 연속
- 설계 원리가 중요함.

### 전통적 설계 방법
- ==분할 정복, 추상화 , 합성등==의 원리를 적용

### 최근의 방법
- ==아키텍쳐 기반의 설계 방법==

### 아키텍쳐의 이해
- 서브시스템, 모듈의 개념
- 설계 작업의 관점, 설계 작업 과정을 숙지

## 01-1 서브시스템 모듈
### 시스템 구조를 이루는 주요 개념
#### 컴포넌트
- 하나의 기능을 가지고 소프트웨어 재사용하기 위해 사용
- 명백한 역할을 지니며, 독립적으로 존재할수 있는 시스템 부분
- 대부분의 컴포넌트들은 재사용 가능하도록 설계
- 소프트웨어의 재사용을 위한 일종의 개발 방법
- 시스템을 구성하는 컴포넌트와 컴포넌트 상호작용의 집합이 아키텍쳐
- 기능의 최소단위, 런타임에 독립적으로 배포되고 실행되는 단위

#### 모듈
- 하나의 기능을 가지고 소프트웨어 재사용을 하기 위해 사용
- 프로그래밍 언어의 문법 구조에서 정의된 컴포넌트
- 구체적인 프로그래밍 언어로 작성된 문법 단위에서 사용되는 용어
- 재사용이 가능한 코드의 모음
- 구조의 최소단위, 정적인 구조

#### 컴포넌트 VS 모듈
- Client-Server 시스템 예시
	- 하나의 서버가 10개의 클라이언트에게 정보를 제공
	- 모듈 : 서버 + 클라이언트 (총 2개)
	- 컴포넌트 : 11개 됨.

#### 서브시스템
- 컴포넌트, 모듈보다 더 추상적 개념으로 여러 다른 방법들로 구현될 개체
- 시스템의 복잡도를 줄이기 위해 분할한 것
- 컴포넌트들의 집합이 서브시스템
	- 서브시스템의 집합 : 시스템
- 복잡한 시스템은 서브시스템을 반복적으로 분할하여 계층화
- [[패키지]] , 다른 서브시스템과 상호작용하기 위하여 정의된 인터페이스를 가짐
>[!note] package
> 클래스들의 모임


#### 설계
- 각 서브시스템이 제공하는 서비스의 명세, 작동되는 제약조건 명시

## 01-2 설계관점
### 개발 과정에 따른 소프트웨어의 다양한 표현
- 요구 모델링 단계 : 유스케이스, 기능 리스트로 표현
- 설계단계 : 서브시스템 구조로 표현
- 구현단계 : 원시코드, 제어 흐름도 등을 표현

### 전통 VS 아키텍쳐
- 전통적 설계 방식 : 기능 실현에 초점
- 아키텍쳐 설계 방식
	- 관점에 근거한 품질 중심의 설계 작업에 초점을 두며, 설계 의도 잘 반영
	- 관점 : 소프트웨어의 구조 , 요소와 관계를 바라보는 방법
	- 아키텍쳐 설계의 3가지 관점 : 모듈 관점, 컴포넌트 관점, 할당 관점

### 아키텍쳐 설계의 3가지 관점
#### 모듈관점
: 일정한 책임을 구현한 코드 단위인 모듈과 그 관계
- 모듈 측면
	- 분할, 사용 관계
	- 게층구조 , 데이터 모델델
#### 컴포넌트 관점 
: 실행될때 동작하는 요소와 상호작용
- 컴포넌트 측면
	- 클라이언트 서버
	- 파이프 필터
	- 출판구독
	- 이벤트 중심
	- 리파지토리

#### 할당 관점
: 소프트웨어으이 하드웨어 설치, 작업 할당 구현, 데이터 저장에 대한 관점
- 할당 측면
	- 배치, 설치 작업 할당
	- 구현, 데이터 저장

## 01-3 설계 작업 과정
- 의사결정 과정 + 시스템을 알아가는 과정
- 시스템 유형, 설계 목적(주로 품질관련)이 아키텍쳐 스타일, 설계 결과에 많은 영향을 미침
	- 예시
		- 보안이 설계의 중요한 목적인 경우 - 보안을 위한 인증 모듈, 정보 보호를 위한 인터페이스를 고려하여 설계
		- 대화형 시스템 - 객체 구조 스타일 , 임베디드 시스템 - 이벤트 스타일 사용
- 일반 적인 설계 과정
	1. 설계 목표 설정 : 
	   전체 시스템에 대한 설계 목표를 파악하고 결정
	2. 스타일 결정 : 
	   시스템이나 서브시스템의 타입 결정을 위해 설계 목표와 유형에 맞는 아키텍쳐스타일을 선택 (적용할수 있는 스타일이 있으면, 이를 적용하고, 없다면 맞춤형으로 아키텍쳐를 설계)
	3. 서브시스템의 기능, 인터이스 명세 :
	    서브시스템 사이의 인터페이스를 정의하고 서브시스템 사이의 상호 작용을 위한 동작을 작성
	4. 아키텍쳐 설계 검토 :
	    설계한 아키텍쳐가 요구, 설계 목표, 설계 원리를 잘 만족하는지 검토

## 02 품질 목표
- 비기는 요구사항이 품질특성
- 시스템 설계안을 결정하는 요소
- 설계안은 여러가지 설계안이 있음
- 시스템이 요구하는 품질 특성을 충분히 컴토하여 반영해야 함.
- 요구하는 품질 특성은 여러개 존재, 서로 상충된 성격 -> 최적안을 판별하는 작업 필요
- 상반되는 품질 요구 간의 절충안을 찾아 설계안을 마련
- 다른 속성이 미치는 영향을 고려

### 설계와 품질 목표표

![[설계와 품질 목표.canvas]]

### ISO 에서 정의하는 소프트웨어 기능 외적인 품질특성
- 성능 : 성능은 일정한 시간동안 특정 작업을 수행하는 시스템의 응답 속도를 보여준다.
	- 단위, 시간당 평균/ 최대 사용자수 
	- 화면 불러오는 평균 시간
	- 평균 실행 시간
- 상호 운용성 : 다른 외부 시스템과의 데이터 전송, 교환을 담당하는 시스템의 속성이다.
	- 지원하는 장치, OS버전, 화면 해상도, 브라우저의 리스트
- 사용용이성 : 사용자가 시스템을 효율적으로 사용하여 만족스러운 정도를 나타내는 속성, 사용자 경험에 익숙한 패턴
	- UI 가속화 요소
	- 사용자 요구 수행 평균 시간
- 신뢰성 : 정의된 조건 아래 계속 작동할수 있는 능력
	- 가용률
	- 다운된 시간
	- 소프트웨어 결함
- 보안성 : 인증, 암호화, 감사등 여러가지 조치가 사용
	- 모듈화 
	- 재사용성
	- 변경 가능성
	- 테스트 가능성
- 유지보수성 : 변경에 대하여 얼마나 잘 수용하는 지를 나타내는 특성
	- 모듈화
	- 재사용성
	- 변경 가능성
	- 테스트가능성
- 이식성 : 시스템이나 구성 요소를 다른 곳으로 쉽게 변환할수 있는 특성
	- 적응성
	- 설치 가능성
	- 대체 가능성

## 03 전통적인 설계 원리
- 단순성 : 복잡한 여러가지 요소를 교통정리 하여 단순화 하거나 복잡함을 최소화
- 효율성 : 사용하는 자원이 적정하고 효과적이도록 한다.
- 분할, 계층화 : 다루기 쉬운 덩어리로 분리, 계층화
- 추상화 : 자세한 부분에 좌우되지않게 컴포넌트 정의 
- 모듈화 : 각 모듈이 외부와의 결합이 낮고 내부 요소가 응집되도록 함.

### 효율성
- 처리 시간과 기억 공간

### 단순성
- 유지보수성에 영향을 주는 가장 중요한 특성

### 추상화
- 복잡한 구조, 원리 , 설명을 간추리고  핵심만 말할것.
- 목적을 명확히 하여 복잡한 것은 숨기고 핵심만 드러내는 것이 추상화의 목적
- 외부에 보이는 동작
- 예시
	- 클라이언트와 서버의 정보교환을 주고받는 메세지의 구조적인 정보만으로 추상화
	1. 클라이언트가 서버의 상태를 탐색
	2. TCP/IP 커넥션 오픈
	3. 메세지를 보내고 응답 기다림
	4. 커넥션을 닫는다.

### 캡슐화
- 추상화된 대상이 제공하는 서비스를 쉽게 접근하게 하는 개념
- 서비스를 수행하는 핵심만을 노출, 어떻게 서비스를 제공하는지 자세한것은 숨김.
- 정보은닉 제공
- 특정 기능을 어떻게 제공하는지에 대한 내용 은닉
- 소프트웨어 설계에서는 모듈을 사용하여 정보은닉을 구현
- 모듈에 포함된 정보는 모듈 외부에 숨기고, 숨겨진 정보에 대한 접근은 신중하게 컨트롤 -> 더 높은 수준의 추상화 제공
- 정보은닉 GOOD ->모듈이 숨겨진 부부넹 대한 변경 사항이 모듈 외부의 내용에 영향을 미치지 않음

### 모듈화
- 문제를 소프트웨어의 구성요소가 될 만한 수준으로 분할하는 과정
- 소프트웨어를 작은 구성요소인 [[패키지]] 또는 클래스로 나누는것.

- 장점
	- 각각의 모듈을 별개로 만들고 수정할수 있음
	- 시스템의 일부를 변경했을떄 다른 부분에 영향을 적게 주게 됨.
- 단점
	- 적당한 모듈화는 소프트웨어에 대한 이해도 높아짐 BUT 너무 많은 모듈로 분할된다면 서로 어떻게 상호작용 하는지 이해하기 어려움.
	- => 모듈화 수준을 적절히 선택

## 03-1 모듈화
### 추상화 VS 모듈화
- 추상화 : 시스템의 핵심 특성에 초점을 두어 하나의 큰 시스템을 분할하는 원리
- 캡슐화 : 분할된 핵심 정보만을 노출
=> 추상화, 캡슐화 원리에 의해 큰 시스템을 잘 모듈화된 시스템으로 완성

### 결합
- 모듈간에 서로 의존하는 정도
- 좋은 소프트웨어는 낮은 결합력을 지님

### 모듈간 결합 정도를 결정하는 요소
- 모듈간 인터페이스
- 각 인터페이스의 복잡성(통신 유형에 따라 결정됨.)

## 03-2 결합
### 내용결합
- 한 모듈이 다른 모듈의 내용을 직접 참조 
- 현재 개발에는 적용 X

### 공통 결합
- 한 모듈이 다른 모듈이 읽은 전역변수 값을 쓰거나 변경

### 제어 결합
- 한 모듈이 다른 모듈의 제어흐름 경로를 결정

### 스탬프 결합
- 복잡 데이터 구조의 일부만 사용하는 모듈에 복잡한 데이터 구조를 전달할때

### 데이터 결합
- 모듈 들이 주고받는 매개변수가 간단한 타입이거나 레코드 안의 필드이더라도 단순한 타입연 경우

## 03-3 응집
- 하나의 모듈 안에서 수행되는 작업들이 서로 관련된 정도
- 모듈 안의 여러 요소들이 하나의 목적을 위하여 유기적으로 관련되어 있는 것이 제일 좋음
- 높은 응집
	- 재사용이 쉽고 이해하기 좋음
	- 수정에 의하여 받는 영향이 적다.
=> 좋은 소프트웨어는 높은 응집력을 가진다.

### 우연적 응집
- 단위 안의 요소들이 의미적으로 아무 관계가 없다.

### 논리적 응집
- 본질적으로는 다르더라도 같은 범주의 기능을 수행, 논리적으로 분류

### 시간적 응집
- 프로그램 실행의 특정한 시간에 처리되므로 한 그룹안에 모여있는 경우

### 절차적 응집
- 모듈 안에엇 수행되는 연산이 프로그램에서 수행되는 순서와 관련

### 교환적 응집
- 모듈의 내부 요소들이 동일한 데이터 조작 -> 그룹화된 경우

### 기능적 응집
- 하나의 기능에 모두 기여하고 밀접하게 관련

### 정보적 응집
- 여러가지 오퍼레이션을 수행하지만 각 오퍼레이션은 각각 고유한 시작점과 독립된 코드가 있고, 모든 오퍼레이션이 같은 데이터에 대해 실행되는 응집
- **객체지향 패러다임은 정보적 응집을 갖도록 설계됨**
	- 각 객체에는 자체 소스코드, 파일이 존재.
	- 각 객체는 객체 안에 정의된 데이터를 조작
	- 객체의 각 맴버 함수는 하나의 고유한 동작 , 오퍼레이션, 함수를 수햄

### 높은 응집과 느슨한 결합
- 응집은 **높은 응집**
- 결합은 **느슨한 결합**

## 04 객체지향 설계 원리
- 전통적인 패러다임의 설계원리는 객체 지향 프로그램의 새로운 특성과 함께 발전
- 객체 지향 개념(상속, 인터페이스) 의 등장으로 재사용, 수정용이성 등의 품질을 높일수 있는 설계원리가 생겨남.

### 객체 지향의 일반적인 설계원칙 : SOLID
- S (Single Responsibility Principle) : 단일 책임 원리
- O (Open Close PRinciple) : 개방 폐쇄의 원리
- L (Liskov Substituion Principle) : 리스코프 교체의 원리
- I (Interface Segregation Principle) : 인터페이스 분리의 원리
- D (Dependency Inversion Principle) : 의존관계 역전의 원리

## 04-1 인터페이스와 구현의 분리
### 인터페이스
- 공개된 메소드의 프로토타입만을 정의해놓은 것.
> 공개된 메소드를 인터페이스로 따로 정의하고 이를 구현 상속

### 인터페이스와 구현의 분리 원칙
- 컴포넌트의 공개 인터페이스를 컴포넌트가 어떻게 구현되는지 상세하게 나타낸것과 분리하자는 것.
- 인터페이스와 분리된 구현은 쉽게 변경 가능

## 04-2 단일 책임의 원리 
### 단일 책임의 원리
- 클래스의 역할과 책임을 단일화 하여 클래스를 변경해야 할 이유르 하나로 제안 

## 04-3 개방 폐쇄의 원리 
### 개방 폐쇄의 원리 
- 소프트웨어 개체(클래스, 모듈, 기능 등) 확장을 위해서는 열려있어야 하지만 수정을 위해서는 닫혀 있어야 하는 원리
- 즉, 한 개체의 변경으로 인해 다른 부분의 변경이 많아지면 안됨.
> 인터페이스 레벨과 구현 레벨의 분리
- 다형성 적용 -> 서로 대체할수 있는 인터페이스 구현 -> 상속을 이용하여 클래스가 정의되어 있을 때 다형성이 적용되어 서로 대체할수 있는 인터페이스를 적용 가능.
- 클래스 자체를 수정하지 않고 클래스를 쉽게 확장 가능

- **여러 순서정렬 알고리즘은 다형성을 이용하여 확장될수 있도록 열려있음.** 
- 함수의 알고리즘 수정이 필요할때 **Client 프로그램 부분은 수정에 영향을 받지 않음**

## 04-4 리스코프 교체의 원리
### 리스코프 교체의 원리
- 클래스 B가 클래스 A에서 상속받은 하위 유형이라면 프로그램의 동작을 방해하지 않고 A를 B로 대체 
- 하위 클래스는 클라이언트의 관점에서 기능을 손상시키지 않는 방식으로 상위 클래스 메소드를 대체
- 상위 타입의 객체를 하위 타입 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다. 


## 04-5 인터페이스 분리의 원리
### 인터페이스 분리의 원리
- 클라이언트가 사용하지 않는 인터페이스를 강제로 구현해서는 안됨.
- 비만 인터페이스(오염된 인터페이스)
	- 하위클래스에 구현된 인터페이스를 추상화 할때, 일부 메서드만 사용하는 다른 모듈이 있어 이를 추가하여 확장하려 한다. 이때 전체 인터페이스에 의존하게 하되, 사용하지 않는 일부 메소드에 대해 더미 메소드를 구현하게 된다.

## 04-6 의존 관계 역전의 원리
### 의존 관계 역전의 원리
- 구체화된 모듈이 추상화 된 모듈에게 의존이 역전되는 설계
- 추상화된 모듈이 구체화된 모듈에 의존하면 안됨.
- 높은 수준의 모듈이 낮은 수준의 추상화된 인터페이스에 의존하게 설계
- 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안되며, 저수준 모듈이 고수준 모듈에 의존해야 한다는 것.

## 05 설계 매트릭
- 설계에 정답은 한개만 존재하는것이 아니라, 정답이 될 만한 여러 후보가 있음. 그 중에서 품질요구, 제약 사항에 가장 잘 만족하는 것을 선택해야 함.

### 전통적인 매트릭
- 크기
	- 모듈 개수, 모듈 사이의 인터페이스 수, 클래스 안에 몇개의 속성과 오퍼레이션이 있는지 카운트 하여 크기 측정
- 복잡도
	- 얼마나 서로 연관되어 복잡한지 나타내는 메트릭으로 구조, 데이터, 시스템 관점의 복합도를 계산식으로 추정
- 결합도
	- 모듈 사이에 실제적으로 어느 정도 연결되어 있는지를 나타내는 척도로 입출력매개 변수, 전역변수, 호출된 모듈 개수의 함수
- 응집도
	- 잘 정의된 단일 목적을 성취하기 위해 오퍼레이션들이 얼마나 잘 협동하는가를 나타내는 척도로 , 데이터 객체와 정의된 위치의 함수로 측정
- 정보흐름
	- 얼마나 많은 정보가 처리되어 흘러가는지를 나타내는 매트릭
	- 전달되는 매개변수,전역변수, 입출력의 개수로 나타냄