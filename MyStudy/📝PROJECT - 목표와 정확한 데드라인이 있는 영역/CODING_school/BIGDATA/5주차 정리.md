
- 기존의 데이터 저장 구조의 한계
    - 저장할 데이터 양 증가 → RDBMS는 읽기/쓰기 제약
    - 수평 확장에 한계 발생
    - 웹 서비스 구조 변화 → 저장할 데이터의 형태가 다양해짐
    - 사용자의 데이터 요구도 다변화
    - CAP(Consistency, Avalilability, Partition Tolerance) 이론 : 일관성과 가용성을 만족 시키기 위한 이론.
    - RDMS로 CAP 이론 충족X → NoSQL이 해결

- CAP이론
    - Consistency, Availability, Partition Tolerance 로 정의
    - ***“어떤 시스템이던 3가지 특성을 모두 만족시키기 어려움. 최대 2가지만 만족”***
        - Consistency (일관성) : 분산 환경에서 모든 노드가 같은 시점에 같은 데이터를 보여줘야 한다.
            - 하나의 노드에 쓰기 작업이 이루어지면 다른 노드에도 복제본이 반영 되어야 함.
            - 사용자가 어떤 노드와 통신하는지 상관없이, 같은 데이터를 보여줘야 함.
        - Availability(가용성) : 일부 노드가 다운되어도 다른 노데어 영향을 주지 않아야함.
            - 시스템이 중단되는 일 없이 언제든지 사용 가능한 상태
            
            <aside>
            🌟 가용성 : 모든 요청이 응답을 받을수 있어야 함을 의미.
            - 사용자가 어떤 작업을 하든, 사용자는 응답을 받을수 있어야 함.
            
            </aside>
            
        - Partition Tolerance( 지속성, 분할 허용성)
            - 네트워크를 통한 데이터 전송중 일부가 데이터가 손실 되더라도 시스템은 정상 동작 햐야 함.
            - 분할 : 노드간 통신이 끊어지는 것을 의미.
            - 분할 허용성 : 시스템 내 분할이 생김 → 여전히 시스템 동작.
                - 한 노드가 다른 노드와 통신할수 없을때, 다른 복제 노드가 사용자 요청에 응답할수 있어야한다. 
                
                복제본을 여러 다른 노드에 저장하여 처리하는것을 의미.
                
                분할이 생기더라도 복제본으로 부터 데이터를 조회.
                - 분할 허용성은 분산 데이터 베이스 시스템에서 필수적이다.

- CAP 이론 정리
    - 분산 데이터 베이스 시스템은 반드시 네트워크 장애, 여러 이유들로 장애가 발생할수 밖에 없음. 분할이 생겼을때, *일관성과 가용성중 하나를 반드시 희생*
    - 반드시 분할 허용성을 가지고 있어야 함.
    - 일관성과 가용성중 하나를 선택해야 한다. (Consistency + Availability : RDBMS)
    - Consistency + Partition Tolerance : 동기화 될때까지 기다림. 데이터 일관성 유지
    (ex_ Bigtable, HBase, Cloudata)
    - Availability + Partition Tolerance : 동기화 안맞더라도 응답 리턴, 가용성 관점(ex_ Dynamo, Cassandra)

- NoSQL 특징
    - “No SQL”
    - RDBMS의 한계 극복
    - 데이터 저장공간의 새로운 형태로 수평적 확정성을 지원
    - 확장성을 지원하는 <key, value> 저장구조
    - 기존의 RDBMS 와 비교하여 제공하는 기능이 적다.
    
    | 구분 | 설명 | 적용 예 |
    | --- | --- | --- |
    | RDBMS | 일관성 + 가용성 (C+P) | 트랜잭션의 ACID를 보장 |
    | NoSQL | 일관성 or 가용성 + 지속성(P) | - C+P형 : 대용량 분산 파일 시스템 (성능 보장)
    - A + P 형: 비동기식 서비스  |

- **ACID : 트랜잭션의 4가지 속성**
- **Atomicity(원자성)**
트랜잭션과 관련된 일은 모두 실행 or 모두 실행되지 않도록 하는 것을 보장
- **Consistency(일관성)**
트랜잭션이 성공했다면, 데이터베이스는 그 일관성을 유지, 특정 조건에서 같은 데이터를 보여주어야 함.
- **Isolation(독립성)**
트랜잭션을 수행하는 도중에 다른 연산작업이 끼어들지 못하도록함.
- **Durability(지속성)**
영속성 = 트랜잭션의 지속성
트랜잭션이 성공적으로 완료된 후 데이터베이스에 반영한 수행결과는 어떤 경우에도 손실되지 않고 영구적이어야 함을 의미. 

트랜잭션이 수행되면 결과를 반영하고 로그를 남김.

트랜잭션은 로그 저장이 완료된 시점에서 종료됨.
이 로그를 이용하여 트랜잭션 수행 전 상태로 되돌릴수 있어야 한다.

- 트랜잭션의 로그가 지원하는 작업
    1. 트랜잭션 복구
        - 개념 트랜잭션 복구 : 애플리케이션이 ROLLBACK문 실행
        - SAL Server 시작시 모든 불완전한 트랜잭션 복구
        - 트랜잭션 복제 지원
    2. 복원된 데이터 베이스 , 파일 , 파일그룹 or 페이지를 오류 지점으로 포워드
    3. 고가용성 및 재해 복구 솔루션 지원 : 데이터베이스 미러링 및 로그 진단.

| 구분 | RDBMS | NoSQL |
| --- | --- | --- |
|  장/단점 | - 데이터 무결성, 정확성 보장
- 정규화된 테이블과 소규모 트랜잭션이 있음
- 확장성에 한계가 있음
- 클라우드 분산 환경에 부적합 | - 데이터의  무결성과 정확성을 보장X
-  웹 환경의 다양한 정보를 검색, 저장 가능 |
| 특성 | - UPDATE, DELETE , JOIN 연산가능
- ACID 트랜잭션이 있음
- 고정 스키마가 있음 | - 수정, 삭제를 사용하지 않음(입력으로 대체)
- 일관성은 불필요
- 노드의 추가, 삭제 및 데이터 분산에 유연 |
- 데이터베이스 정규화(Normalization)
    - 이상현상이 발생하는 테이블을 수정하여 정상으로 만드는 과정
    - 이상현상
        
        두가지 이상의 정보가 한 릴레이션(행+열=테이블)에 저장되어 발생, 
        릴레이션을 분해하여 이상현상 제거 
        

- NoSQL의 기술적 특성
    - 스키마가 없다.
        - 스키마
            
            데이터 구조를 명확하게 정의 , 데이터의 유효성 검사 및 데이터 처리, 교환을 효과적으로 관리함. (데이터 구조, 데이터베이스의 테이블 레이아웃…)일련의 규칙과 구조
            
        - 키 , 값을 통해 다양한 형태의 데이터 저장 + 접근
        - 데이터 저장 방식은 열(Column), 키-값(value), 문서 (Document), 그래프(Graph) 4가지로 구분함.
    - 탄력성(Elasticity)
        - 시스템 일부에 장애 발생해도 클라이언트가 시스템에 접근 가능
        - 시스템 규모, 성능 확장, 입출력의 부하 분산에 용이한 구조
    - 질의 가능(Query)
        - 데이터를 검색/처리 할수 있는 질의 언어 및 API제공
    - 캐싱(Caching)
        - 메모리 기반 캐싱 기술 적용
    

NoSQL의 분류와 특징

| 데이터 모델 | 특징 | 제품 예 |
| --- | --- | --- |
| <키, 값> 저장구조 | - 가장 간단한 데이터 모델|
|- 응용 프로그램 모델링이 복잡 | - 아마존 Dynamo DB|
|- 아마존 S3 |
| 문서 저장 구조 | - 키, 값 저장구조의 확장된 형태로 값에 문서를 저장|
|- 문서는 구조화된 문서 데이터 | - 아마존 simple DB|
|- 아파치 Couch DB|
|- Mongo DB |
| 열 기반 저장 구조 | - 연관된 데이터 위주로 읽는데 유리함. |
|- 하나의 레코드를 변경하려면 여러곳을 수정해야함.|
|- 동일 도메인의 열값이 연속되므로 압축 효율 좋음|
|- 범위 질의에 유리 | - 아파치 Cassandra |

- 빅데이터 주요 저장 및 관리 기술
    - HDFS (아파치):분산 환경에 기반한 데이터 관리
    - DynamoDB (아마존) : SSD를 이용한 하둡 기반 데이터 분석, 저장
    - Mongo DB(10gen) : DB의 수평 확장 및 범위 질의 , 맵 리듀스 연산
    - Couch DB (D.Katz) : ACID 속성을 이용한 분산 데이터베이스
    - Cassandra(A.Lakshman) : 데이터의 저장 및 처리, 제한적 정렬
    - HBase (아파치) 
    - 분산 클러스터 관리 및 복구
    - 데이터의 Get/Put/scan/Delete 기능
    - ZooKepper (아파치) : 여러 종류의 하둡 기반 시스템의 관리

- S3(Simple Storage Service)
- 개요
    - 아마존에서 개발한 인터넷 스토리지 서비스
- 주요 기능
    - 저장 기능
        - 객체의 읽기 쓰기 삭제가 가능
        - 각 객체는 (Bucket, 객체(데이터))를 저장하기 위한 컨테이너에 저장됨
        - 버킷은 여러 지역중 한곳에 저장할수 있으며, 지연 시간 최소화, 규정 요구 사항 준수등 다양한 필요에 따라 지역을 선택할수 있다.
    - 보안 기능
        - 한 지역에 저장한 객체는 사용자가 다른 지역으로 옮기지 않는 한 해당 지역 밖으로 이동하지 않음.
        - 무단 액세스로 부터 데이터를 안전하게 보호할수 있도록 인증 메커니즘을 제공
        - 안전한 데이터의 업로드 및 다운로드 옵션과 데이터 암호화 옵션을 제공
    - 개발 인터페이스 제공(인터넷에서 사용할수 있도록)
        - REST(Representational State Transfer), SOAP(Simple Object AccessProtocol)인터페이스 사용
    - 지역별 데이터 센터 운영
        - S3는 미국,  EU , 싱가포르 , 도쿄, 상파울루, Gov Cloud 에서 사용

- HDFS(Hadoop Distributed File System)
- 개요
    
    ASF에서 제공하는 분산 파일 시스템을 관리하는 오픈소스 프레임 워크
    
- 주요 기능
    1. 맵 리듀스를 이용한 분산 , 병렬처리 지원
    2. 수십-수천대의 클러스터로 구성
    - (하나의)마스터 - (수십~수천대의)슬레이브로 클러스터 구성
    - 마스터 노드 = NameNode
    슬레이브 노드 =  DataNode
    - 블록은 DataNode에 저장. 이 블록들의 메타 정보는 NameNode에 저장됨.
    - 메타 데이터에 저장되는 정보
        1. file과 chunk(64MB)의 namespace
        2. file to chunk mapping 정보
        3. chunk의 위치 저장
    1. 파일 저장시 여러 블록으로 분산하여 저장
    : 블록들은 마지막 블록을 제외하고 크기가 동일.(64MB or 사용자 설정)
    2. Replication(복제) 기법 사용
    블록이 손상을 입으면 파일 전체에 문제가 생김 
    → 동일한 블록을 다른 노드(동상3대) 복사하는 복제 기법을 사용

- NameNode : DataNode에 저장되는 블록들의 정보 저장
    - DataNode 블록의 메타데이터 정보 관리
    - DataNode 모니터링 : 3초마다 Heartbeat를 전송함.
    - Heartbeat
        
        DataNode가 살아있는지 체크하는 기능
        
    - 블록 관리 : 장애가 발생한 데이터 노드의 블록을 새로운 DataNode에 복제함.
- DataNode : 데이터 블록을 분산 저장
    - 대용량 파일을 HDFS에 저장하면 하나 이상의 블록으로 분산되어 여러 DataNode에 저장됨.

- HDFS 분산 저장 구조 : 여러대의 서버에 데이터를 분산하여 저장. 저장된 각 서버에서 동시에 데이터를 처리하는 방식.
    - 처리 흐름도
    파일 저장 : 클라이언트와 NameNode 통신 → 저장 개시 → 패킷 전달
        - 클라이언트와 NameNode 통신
        - 클라이언트 → NameNode 저장을 위한 파일 열기 요청.
        NameNode에 파일 작성을 요구
        - 요구를 접수한 NameNode는 허가  용량을 체크, 파일을 저장할수 있는 상태인지 확인.
        - 메타데이터에 파일 엔트리 추가
        - 클라이언트는 데이터 전송 큐 감시.

- 저장 개시
    - 클라이언트가 저장용 스트림을 받으면 
    클라이언트가 파일 저장 시작.
    - 받은 데이터를 패킷이라는 단위로 전송 큐에 삽입
    - 데이터 전송 큐안에 패킷이 삽입되어있는 것을 확인하면 NameNode에 블록 할당을 요구함
    - 패킷 저장대상 DataNode 리스트를 수신
    - 이 리스트에서 복제 수와 동일 수의 DataNode를 연결한 파이프라인 형성
    → 데이터 전송 큐에서 패킷을 꺼내 파이프라인 선두에 있는 DataNode에 기록
    → 이와 동시에 별도 스레드로 관리하고 있는 ack 대기 큐에 패킷을 저장해 둔다.

- 패킷 전달
- 파이프라인 : 데이터가 전달되는 경로나 처리를 위한 기반 전체를 ‘데이터 파이프라인’ 이라함.
    - 패킷이 기록된 DataNode는 파이프라인에 포함된 다른 DataNode에 패킷을 차례로 전달
    패킷 전달은 Rack awareness 를 포함하는 리플레케이션 규칙을 따름.
    - 두번째 복제본을 기록 할때는 첫번째 복제가 저장된DataNode와 다른 랙에 있는 DataNode에 전달
    - 세번째 복제본은 두번째 복제본이 전달된DataNode와 동일 랙에 있는 다른 DataNode에 전달.
    - 패킷이 정상적으로 기록된 DataNode는 ack 메세지를 파이프 라인 상부에 통지
    - ack 메세지는 파이프라인을 전달하고 최종적으로 클라이언트에 도착한다.
    - ack가 도착하면 대응 패킷이 ack 큐에서 제거된다.
    - 파이프라인에 따른 데이터 저장은 노드간에 비동기로 진행, 파이프라인을 닫을때는 해당 블록 저장이 모두 완료되고 ack가 돌아올때 까지 기다린다.
- Rack awareness
    
    모든 복제본이 동일 랙상의 DataNode 세대에 배치가 되면, 해당 랙상의 스위치 장애에 의해 모든 복제본을 잃을수 있는데, 이를 방지하기 위해 복제본이 동일 랙상에 존재하지 않도록 배치를 조정.
    
    Hadoop config 파일에서 설정한다.
    

- 저장중에 장애가 발생할 경우
    - ack 큐 내부에 있는 패킷을 모두 데이터 전송 큐로 이동한다.
    - 장애가 발생한 DataNode를 제외시킨 새로운 파이프라인을 형성, 다시 파이프라인에 저장한다.
- 새로운 블록을 할당하기 위해 클라이언는 다시 NameNode로 부터 DataNode 리스트를 취득하고 새로운 파이프라인을 형성한다.
클라이언트는 반복해서 모든 데이터 저장을 마치면 작업을 끝낸다.

- HDFS에서 파일 읽기
1. 파일 열기와 DataNode 리스트 요구
2. 읽을 대상 블록과 DataNode리스트 반환
3. DataNode에서 블록 읽기
4. DataNode에서 블록 읽기를 반복

- 파일 읽기 : 클라이언트와 NameNode와의 통신 → 읽기 개시 순으로 진행하며, 블록을 읽을 때는 클라이언트와 가장 가까운 DataNode를 선택한다.

- 클라이언트와 NameNode의 통신하기
    - HDFS 에서 파일을 읽을때는 NameNode에 읽기 전용 파일 열기를 요청하는데 , 요구한 파일 블록을 가진 DataNode 리스트를 요청한다.
    - 클라이언트로 부터 요청을 NameNode는 오픈때 부여한 파일 경로에서 해당 파일을 구성하는 블록 기스트 생성  → 해당 블록들을 가지고 있는 DataNode 리스트를 클라이언트에 전달
- 읽기 개시
    - 클라이언트는 취득한 정보로부터 파일 읽기를 개시
    - 최초 블록을 가지고 있는 DataNode에 접속해서 블록을 읽는다.
    - 블록을 읽을때는 클라이언트로 부터 거리가 가장 가까운 DataNode를 선택한다.
    - 블록의 마지막 부분까지 읽으면 다음 블록을 가진 DataNode에 접속해서 다시 블록을 읽는다.
    - 이것을 반복하여 파일 읽기를 끝내면 클라이언트는 파일 닫기를 요구한다.

- DynamoDB
- 개요
    - 아마존에서 개발한 키-값 및 도큐먼트 자료구조를 지원하는 NoSQL 데이터 베이스
    - 아마존 웹 서비스의 하나로 제공
- 특징
    - 두가지 용량 모드 지원
    1. 온 디맨드 방식 : 사용한 만큼 비용 지불, 원하는 만큼 데이터베이스를 생성하거나 삭제하여 데이터를 저장
    - 온 디맨드 백업 기능 : 사용 계약 요건 맞도록 유지하고 보관
    1. 프로비저닝 방식 : 트래픽 변경에 따라 프로비저닝된 용량을 자동 조정.
    ex_) 애플리케이션에 필요한 초당 읽기 및 쓰기 횟수 지정.
    
    - 리소스 사용 및 성능 지표 모니터링 제공
    - 특정 시점으로 복구 기능 제공 : 35일 중 원하는 시점으로 테이블 복원 가능
    - 자동 삭제 기능 제공 : 관련 없는 데이터를 저장하는데 비용을 낭비하지 않아도 된다.
    - 하둡 기반의 데이터 분석 기능과 데이터 저장 서비스 지원

- DynamoDB의 구성 요소
    - 속성(attributes) : 나눌수 없는 데이터의 기본적인 요소
    - 항목(items) : 속성들의 집합
    항목은 여러개로 구성되며 전체 항목들 사이에 유니크하게 구별됨
    - 테이블(tables) : 데이터의 집합소 
    테이블은 여러개의 항목으로 구성 , 테이블에 데이터를 저장
- DynamoDB에 데이터를 저장할 때는 테이블을 생성한 후 기본키와 함께 테이블 이름을 지정.

- MongoDB
- 개요
    - 10gen에서 개발
    - NoSQL 데이터 베이스
    - 신뢰성과 확장성에 기반한 문서 지향 데이터 베이스임.
- 특징
    1. 자동화된 샤딩 기능 제공
        - 자동 샤딩을 이용한 분산 확장이 가능.
        - 데이터를 여러 서버로 분할 저장 → 더 많은 데이터를 관리하고 처리
    2. 수평적 확장 기능
        - 기존 RDBMS의 범위 질의, 보조 인덱스, 정멸등의 연산 기능과 맵 리듀스의 집계 연산을 함께 지원한다.
    3. 문서 단위 저장(RDBMS의 행과 비슷함)
        - 각 문서들은 컬랙션(RDBMS의 테이블과 비슷)에 수집.
        - 각 컬렉션은 데이터베이스에서 관리
        - 스키마 필요X
    4. Javascript를 이용한 질의 : Javascript로 작성, 문서 기반의 질의 지원

- 샤딩의 개념
- 샤딩 정의 : 데이터를 분할하여 다른 서버에 나누어 저장하는 과정.
소프트웨어적으로 데이터베이스를 분산 시켜 처리하는 구조를 말함.
- 샤딩 목적
    - 분산 저장
        - 한대의 서버에 빅데이터를 저장하는것은 불가능함.+ 서비스 성능 저하
        - 데이터를 분산 → 순차적으로 저장 ⇒ 여러대의 트래픽을 감당 → 부하를 분산하는 효과O
        - 데이터를 여러 서버에 분할 → scale-up 하지 않고도 더 많은 데이터를 저장, 처리
    - 백업과 복구
        - 데이터를 분산 저장하는 샤딩 기능 사용 → 시스템 성능 향상 + 데이터 유실 가능성Down
        - 서버데이터가 유실되면 상상을 초월한 피해 발생
        - 데이터 복구에 엄청난 시간과 노력 소요
        - 따라서 미리 데이터를 분산하여 저장하면 리스크로부터 보호 받음.
            
            → 효과적인 시스템 운영 가능
            
    - 빠른 성는 보장
        - 여러대의 독립된 프로세스가 병렬로 작업을 수행 → 처리 성능 보장
- 샤딩이 필요한 시점
    1. 서버의 저장 공간이 부족할때
    2. 처리량을 증가 시켜야 할때
    3. 성능 향상을 위해 메모리 확장이 필요할때.
    
- 몽고 DB의 구성요소
- Config 서버
    - 샤드 서버에 대한 메타데이터 관리와 인덱스 정보 검색
    - 메타데이터
        
        각 샤드 서버에 어떤 데이터들이 어떤식으로 분산저장 되어있는지 정보 저장.
        
    - 샤드 서버와 별도의 서버에 구축. 장애 발생에 대비하여 백업용 서버 구성 필요.
    샤드 서버에 비해 저 사양의 서버도 사용 가능.
- Mongos 서버
    - 라우팅 역할을 하는 서버
    - Config 서버의 메타데이터를 읽어옴.
    - 데이터를 샤드 서버로 분산
    - Client는 Mongos에서 자신과 연결된 샤드 서버에 질의 및 결과를 취합해서 다시 클라이언트에 전송
- 샤드 서버
    - 물리적으로 데이터가 저장되는 MongoDB 서버를 지칭
    - Mongos 아래에 3대의 샤드 서버가 구성.
    - 하나의 샤드 서버에는 3개의 Mongod서버로 구성

- CouchDB(Cluster Of Unreliable Commodity Hardware DB)
- Couch DB
    - Couch DB는 ASF에서 관리함.
    - JavaScript로 구성된 문서 기반 NoSQL 데이터 베이스 , ErlangOTP(Open Telecom Platform) 를 기반으로 함.
- CouchDB 특징
    - MVCC(Multi Version Concurrenct Control, 다중 버전 동시 동작 제어기능) 기능 제공
        - 쓰기 중에 데이터베이스 파일을 잠그지 않으며, 충돌은 애플리케이션이 해결
    - 충돌(Conflicts) 감지 및 관리 : 분산 편집 시스템의 핵심 문제
    - 충돌
        
        문서의 여러 사본에 독립적인 업데이트를 수행하면 문서의 최종 컨텐츠에 충돌이나 불일치가 생기는 현상
        
    - Couch DB는 데이터베이스 인스턴스가 승자 문서와 충돌 문서를 결정 알고리즘으로 결정
- 문서 보관 : CouchDB의 기본 단위 , 문서에는 데이터베이스 시스템에서 유지 관리하는 메타 데이터가 포함됨.
- ACID 속성
    - Atomicity : 트랜잭션과 관련된 일은 모두 실행되던지 , 모두 실행되지 않도록 하는것을 보장
    - Consistency : 트랜잭션이 성공 했다면, 데이터베이스는 그 일관성을 유지, 특정 조건에서 같은 데이터를 보여주어야 함.
    - Isolation : 트랜잭션을 수행하는 도중에 다른 연산 작업이 끼어들지 못하도록 함.
    - Durability : 트랜잭션의 지속성은 트랜잭션이 성공적으로 완료된 후 , 데이터베이스에 반여한 수행 결과는 어떤 경우에도 손실되지 않고 영구적이어야함을 의미. 트랜잭션이 수행되면 결과를 반영하고 로그를 남긴다.
    - 트랜잭션은 로그 저장이 완료된 시점에서 종료된다. 이 로그를 이용해 트랜잭션 수행 전 상태로 되돌릴수 있어야 한다.

- 압축기능
    - 낭비되는 공간은 압축하여 회수한다. 데이터베이스 파일이 일정량의 낭비된 공간을 초과하면 Couch DB의 압축 프로세스는 모든 활성 데이터를 새 파일로 복제한 다음, 이전 파일을 삭제한다.
- 보안 및 검증
    - Couch DB는 누가 문서를 읽고 수정할수 있는지 제한, 간단하면서도 확장 가능한 보안 모델을 가지고 있다.
        - 관리자 접근 : 관리자 계정의 경우 다른 관리자 계정을 만들거나 설계 문서를 수정 가능.
        - 리더 접근 : CouchDB 문서에 리더 목록을 저장 , 정의된게 없으면 누구나 읽을수 있다.
        욕특이 정의되어 있는 경우 → 지정된 사용자만 읽기 가능. 뷰에서 접근 할때도 이 접근 제한이 동일하게 적용된다. 접근 권한이 없으면 부 조회 결과에서 빠지도록 되어 있다.
        - 업데이트 접근 : 디스크에 문서를 쓰는 시점에 자바스크립트 함수를 이용하여 유효성 검증이 이뤄진다. 유효성 검증을 용과하면 그대로 업데이트 진행
- 뷰
    - 비정형 데이터를 다루기 위해 자바스크립트 함수를 이용해 데이터 가공을 처리함. 이 자바스크립트 함수를 뷰라고 함. MapReduce 모델로 되어있다.
    - 분산 업데이트 및 복제
    - P2P 기반의 분산 데이터 베이스 시스템이므로, 사용자와 서버는 연결이 끊긴 상태에서 공유 데이터에 액세스 및 업데이트 할수 있음. 양방향 복제가 가능
    - 전체 데이터베이스 애플리케이션을 원격 서버에 복제할수 있다.

- Cassandra 개요
    - <키,값> 구조의 DBMS.
    - 최초로 개발한 대용량 데이터 처리가 가능한 비관계형 분산 데이터베이스 관리 시스템.
    - ASF에서 관리
    - 확장성과 고 가용성에 최적화된 대표적인 분산형 데이터 저장소
    - P2P 형태의 링 구조이며, Master-Slave가 없는 ! 링형 Masterless로 비동기 복제를 수행
    - 아마존의 다이나모 DB의 분산 디자인과 구글 빅테이블의 데이터 모델을 기반으로 설계되었고, 다이나모DB의 해시 알고리즘을 이용한<키, 값>저장구조와 계층적 열 구조를 사용함.

- Cassandra 특징
    - 토큰  링 구조 : 서버 (노드)의 추가 및 제거만으로도 전체 저장 공간의 유연한 확장 및 축소 가능
    - 데이터 복제본 구성 : 노드에 장애가 발생해도 서비스에 영향을 주지않고, 데이터가 유실되지 않는다.
    - 빠른 성능 : MySQL 대비 8~15배 빠른 성능
    수정 추가 , 삭제할떄 스토리지에 적용하기 전에 Commit Log에 변경 사항을 기록하므로 MySQL 대비 8~15 배 빠른 성능
    - SSTable 사용 : 물리 파일 저장 구조롤 SSTable(Sorted String Table)을 사용한다.
    - Scale out 구성
    클러스터의 중단 없이 규모를 확대나 축소할수 있는 Scale out을 사용하므로 변경이 발생하더라도 구성을 건드릴 필요가 없다.
    - 고 가용성과 결함 허용
        - 클러스터에서 시스템을 중단하지 않고, 장애가 발생한 노드를 교체 할수 있고, 다중 데이터 센터에 데이터를 복제해 로컬 성능을 개선할수 있다.
        - SQL 과 비슷한 CQU(Cassandra Query Langauge) : CREATE, INSERT, SELECT을 사용한다.
    - 분산화와 비 집중화
        - 분산형 : 여러 머신에서 동작하며 , 물리적으로 떨어져있는 데이터 센터간에도 단일 클러스터를 운영할수 있다.
        - 비 집중화 링 구조 : 모든 노드가 같아서 마스터 X , 
        P2P 프로토콜 사용, 활성 노드와 비활성 노드의 목록을 동기화 하고 유지관리 한다.
    
- SSTable
    - 입력이 요청된 데이터는 디스크에 바로 기록되지 않고, 메모리내의 MemTable에 기록.
    - MemTable이 어느정도 차면 MemTable 저체를 통째로 Disk에 Write 하는데, 이 과정을 Flushing이라고 함.
    - Disk로 Write 되는 파일을 SSTable 이라고 한다 .
    - 메모리의 데이터가 스토리지로 Flush될때, DB는 데이터를 SSTable이라는 자료구조에 담아서 보관한다.

- Column : 컬럼 이름과 값으로 이뤄진 데이터 구조체
- Column Family : 컬럼들의 집합. 컬럼 패밀리는 하나의 ROW를 식별하기 위한 Key를 가지며, 하나의 Key에 여러개의 컬럼이 달려있는 형태.
- Schemaless : 각 행의 데이터 스키마가 다름. Cassandra는 각 행마다 다른 형태의 데이터 스키마를 사질수 있는데, 이런 특징을 Schemaless라고 한다.
- Key Space
Key Space는 논리적으로  Column Family를 묶어주는 개념이며, 단지 묶어만 줄 뿐, 데이터 구조나 관계에는 영향을 주지 않는다.

- HBase(Hadoop Database)
- 개요
    - HBase는 아파치 오픈소스 NoSQL 솔루션으로 Big Table 논문을 참조하여 개발됨.
    - <키,값> 기반의 NoSQL이며, 대용량 데이터를 빠르게 처리할수 있는 기능을 가짐.
    - 행, 열 그룹, 열 이름, 타임스탬프를 이용한 테이블 구조
    - 하둡 파일 시스템 위에 설치됨.
    - Zookeeper를 노드 관리에 사용된다.